---
title: "Community data analysis using the vegan package in R"
author: "Naupaka Zimmerman and Gavin Simpson"
date: "August 9, 2014 • ESA 2014"
output:
  ioslides_presentation:
    fig_height: 6
    fig_width: 7
    highlight: tango
    keep_md: yes
    widescreen: yes
bibliography: intro-basics.bib
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(comment = "", cache = TRUE)
```

<!----------------------------slide boundary--------------------------------->

## Workshop logistics

* Etherpad 
    * https://etherpad.mozilla.org/ESA2014-vegan

<!----------------------------slide boundary--------------------------------->

## Workshop logistics

* Etherpad 
    * https://etherpad.mozilla.org/ESA2014-vegan
* Red and Green Stickies 
  
![](img/Green_post_it.png)&nbsp;&nbsp;&nbsp;&nbsp;![](img/Red_post_it.png)

<!----------------------------slide boundary--------------------------------->

## Packages installed?

```{r, eval=FALSE}
install.packages("vegan", dependencies = TRUE)
install.packages("plyr")
install.packages("reshape2")
```

### Data downloaded from github?  
https://github.com/naupaka/esa_vegan

<!----------------------------slide boundary--------------------------------->

## Introduction to **vegan**

* What is it?
* Who developed it?
* How does it differ from other alternatives?

<!----------------------------slide boundary--------------------------------->

# Cleaning and importing data

<!----------------------------slide boundary--------------------------------->

## Digging in | Prepping your data for R and vegan

### “The purpose of computing is insight, not numbers” 
### - Richard Hamming 

<!----------------------------slide boundary--------------------------------->

## Digging in | Prepping your data for R and vegan

### “The purpose of computing is insight, not numbers” 
### - Richard Hamming 
<br /><br /><br />
But you have to get through the numbers to get to the insight...

<!----------------------------slide boundary--------------------------------->

## Digging in | Prepping your data for R and vegan

We've all heard data horror stories
![](img/otherpeoplesdata.png)

<!----------------------------slide boundary--------------------------------->

## Cleaning your data for R and vegan

### Loading dirty data and then cleaning
```{r, eval=FALSE}
setwd("your/working/directory/")
BCI.small.csv.in <- read.csv("data/BCI_small.csv", header = TRUE, row.names = 1)
```

<!----------------------------slide boundary--------------------------------->

## Cleaning your data for R and vegan

### Loading dirty data and then cleaning
```{r, eval=TRUE}
BCI.small.csv.in <- read.csv("data/BCI_small_fixed.csv", header = TRUE, row.names = 1)
```

<!----------------------------slide boundary--------------------------------->

## Cleaning your data for R and vegan

Then...  
```{r}
head(BCI.small.csv.in, n=3)
```

<!----------------------------slide boundary--------------------------------->

## Cleaning your data for R and vegan

Then...  
```{r}
summary(BCI.small.csv.in)
```

<!----------------------------slide boundary--------------------------------->

## Cleaning your data for R and vegan

We will now switch to using one of vegan's built-in datasets for species (`BCI`) and environmental variables from the same paper, which we will load directly
    
* from Condit et al. 2002 *Science*

```{r, results='hide'}
library("vegan")
data(BCI)
BCI.env <- read.csv("data/BCI.env.csv", header = TRUE, row.names = 1)
```

<!----------------------------slide boundary--------------------------------->

## Cleaning your data for R and vegan

We will now switch to using one of vegan's built-in datasets for species (`BCI`) and environmental variables from the same paper, which we will load directly
    
* from Condit et al. 2002 *Science*

```{r, results='hide'}
library("vegan")
data(BCI)
BCI.env <- read.csv("data/BCI.env.csv", header = TRUE, row.names = 1)
```

```{r}
head(BCI[,1:3], n = 3)
```

<!----------------------------slide boundary--------------------------------->

# Basic data summarizing

<!----------------------------slide boundary--------------------------------->

## Summarizing data with `apply()` | sums and sorting

**Sum of rows**
```{r}
sum.of.rows <- apply(BCI, 1, sum)
sort(sum.of.rows, decreasing = TRUE)[1:8] #top 8 rows (plots) 
```

<!----------------------------slide boundary--------------------------------->

## Summarizing data with `apply()` | sums and sorting

**Sum of rows**
```{r}
sum.of.rows <- apply(BCI, 1, sum)
sort(sum.of.rows, decreasing = TRUE)[1:8] #top 8 rows (plots) 
```
**Sum of columns**
```{r}
sum.of.columns <- apply(BCI, 2, sum)
sort(sum.of.columns, decreasing = TRUE)[1:3] #top 3 columns (species)
```

<!----------------------------slide boundary--------------------------------->

## Summarizing data with `apply()` | sums and sorting

**Number of plots in which each spp. occurs**
```{r}
spec.pres <- apply(BCI > 0, 2, sum) 
sort(spec.pres, decreasing = TRUE)[1:18]
```

<!----------------------------slide boundary--------------------------------->

# Data Transformation

<!----------------------------slide boundary--------------------------------->

## Basic data transformation

**Square root transformation**
```{r}
head(BCI[,162:164], n = 3)
```

<!----------------------------slide boundary--------------------------------->

## Basic data transformation

**Square root transformation**
```{r}
head(BCI[,162:164], n = 3)
spec.sqrt <- sqrt(BCI)
head(spec.sqrt[,162:164], n = 3)
```

<!----------------------------slide boundary--------------------------------->

## Data transformation in vegan with `decostand()`

**Total**
```{r}
head(BCI[,162:164], n = 3)
```

<!----------------------------slide boundary--------------------------------->

## Data transformation in vegan with `decostand()`

**Total**
```{r}
head(BCI[,162:164], n = 3)
spec.total <- decostand(BCI, method = "total", MARGIN = 1) # by rows (sites)
head(spec.total[,162:164], n = 3)
```

<!----------------------------slide boundary--------------------------------->

## Data transformation in vegan with `decostand()`

**Maximum**
```{r}
head(BCI[,162:164], n = 3)
```

<!----------------------------slide boundary--------------------------------->

## Data transformation in vegan with `decostand()`

**Maximum** 
```{r}
head(BCI[,162:164], n = 3)
spec.max <- decostand(BCI, method = "max", MARGIN = 2) # by columns (species)
head(spec.max[,162:164], n = 3)
```

<!----------------------------slide boundary--------------------------------->

## Data transformation in vegan with `decostand()`

**Presence-Absence**
```{r}
head(BCI[,162:164], n = 3)
```

<!----------------------------slide boundary--------------------------------->

## Data transformation in vegan with `decostand()`

**Presence-Absence**
```{r}
head(BCI[,162:164], n = 3)
spec.pa <- decostand(BCI, method = "pa")
head(spec.pa[,162:164], n = 3)
```

<!----------------------------slide boundary--------------------------------->

## Data transformation in vegan with `decostand()`

**Hellinger (Legendre & Gallagher 2001)**
Square root of method "total"
```{r}
head(BCI[,162:164], n = 3)
```

<!----------------------------slide boundary--------------------------------->

## Data transformation in vegan with `decostand()`

**Hellinger (Legendre & Gallagher 2001)**
Square root of method "total"
```{r}
head(BCI[,162:164], n = 3)
spec.hellinger <- decostand(BCI, method = "hellinger", MARGIN = 1) # on rows (sites)
head(spec.hellinger[,162:164], n = 3)
```

<!----------------------------slide boundary--------------------------------->

## Data transformation in vegan with `decostand()`

**Wisconsin double standardization**  
Shortcut function for standardizing species to maximum, then sites by totals.  
```{r}
head(BCI[,162:164], n = 3)
```

<!----------------------------slide boundary--------------------------------->

## Data transformation in vegan with `decostand()`

**Wisconsin double standardization**  
Shortcut function for standardizing species to maximum, then sites by totals.
```{r}
head(BCI[,162:164], n = 3)
spec.wisc <- wisconsin(BCI)
head(spec.wisc[,162:164], n = 3)
```

<!----------------------------slide boundary--------------------------------->

# Calculating community distances

<!----------------------------slide boundary--------------------------------->

## Calculating distances with `vegdist()` | so many distance metrics, so little time!

### Many different community distance metrics are available in `vegdist()`    
*manhattan, euclidean, canberra, bray, kulczynski, jaccard, gower, altGower, morisita, horn, mountford, raup, binomial, chao, or cao*

<!----------------------------slide boundary--------------------------------->

## Calculating distances with `vegdist()` | so many distance metrics, so little time!

### Many different community distance metrics are available in `vegdist()`   
*manhattan, euclidean, canberra, bray, kulczynski, jaccard, gower, altGower, morisita, horn, mountford, raup, binomial, chao, or cao*

```{r}
spec.jaccpa <- vegdist(BCI, method = "jaccard", binary = TRUE)
# returns an object of class 'dist'
str(spec.jaccpa) 
```

<!----------------------------slide boundary--------------------------------->

## Calculating distances with `vegdist()` | so many distance metrics, so little time!

```{r}
as.matrix(spec.jaccpa)[1:4,1:4]
```


<!----------------------------slide boundary--------------------------------->

## Calculating distances with `vegdist()` | so many distance metrics, so little time!

### How to choose a good one for your data set?  
### First step, read the help for vegdist
```{r}
?vegdist
```

<!----------------------------slide boundary--------------------------------->

## Calculating distances with `vegdist()` | so many distance metrics, so little time!

### Second, try `rankindex()`    
Higher rank correlations indicate better separation along gradients
```{r}
rank.UTM.NS <- rankindex(BCI.env$UTM.NS, BCI, indices = 
              c("bray", "euclid", "manhattan", "horn"), method = "spearman")
rank.UTM.NS
```

<!----------------------------slide boundary--------------------------------->

## Calculating distances with `vegdist()` | so many distance metrics, so little time!

### Second, try `rankindex()`    
Can also use on standardized data
```{r}
rank.UTM.NS.wisc <- rankindex(BCI.env$UTM.NS, wisconsin(BCI), indices = 
              c("bray", "euclid", "manhattan", "horn"), method = "spearman")
rank.UTM.NS.wisc
```

<!----------------------------slide boundary--------------------------------->

## Calculating distances with `vegdist()` | comparison

```{r}
sort(rank.UTM.NS, decreasing = TRUE)
sort(rank.UTM.NS.wisc, decreasing = TRUE)
```

<!----------------------------slide boundary--------------------------------->

# Diversity metrics

<!----------------------------slide boundary--------------------------------->

## Alpha diversity

Basic counts of richness for each plot or site
```{r}
site.richness <- apply(BCI > 0, 1, sum)
site.richness[1:18]
```

<!----------------------------slide boundary--------------------------------->

## Alpha diversity | Other metrics

Fisher's alpha
```{r}
site.fisher <- fisher.alpha(BCI)
site.fisher[1:12]
```

<!----------------------------slide boundary--------------------------------->

## Alpha diversity | Other metrics

Shannon diversity
```{r}
site.shannon <- diversity(BCI, index = "shannon", MARGIN = 1)
site.shannon[1:12]
```

<!----------------------------slide boundary--------------------------------->

## Rarefaction

This is the same as `apply(BCI > 0, MARGIN = 1, sum)`    
it gives the species count for each plot
```{r}
BCI.S <- specnumber(BCI)
```
This finds the plot with the least number of individuals
```{r}
# could also use rowsums() instead of apply()
BCI.raremax <- min(apply(BCI, 1, sum))
```

<!----------------------------slide boundary--------------------------------->

## Rarefaction

Rarefy BCI species matrix to the minimum number of individuals in any plot    
and plot the relationship between observed and rarefied counts (plus add 1-1 line)
```{r, fig.height=3.5}
BCI.Srare <- rarefy(BCI, BCI.raremax)
plot(BCI.S, BCI.Srare, xlab = "Observed No. of Species", ylab = "Rarefied No. of Species")
abline(0, 1)
```

<!----------------------------slide boundary--------------------------------->

## Rarefaction

Put it all together
```{r, fig.height=4.5}
rarecurve(BCI, step = 20, sample = BCI.raremax, col = "blue", cex = 0.6)
```

<!----------------------------slide boundary--------------------------------->

## Beta diversity

Multivariate homogeneity of groups dispersions
```{r}
BCI.bray <- vegdist(BCI, method = "bray")
betadisper(BCI.bray,group = as.factor(BCI.env$UTM.NS))
```

<!----------------------------slide boundary--------------------------------->

## Beta diversity

Boxplot of within-group multivariate dispersion
```{r, fig.height=4.5}
boxplot(betadisper(BCI.bray,group = as.factor(BCI.env$UTM.NS)))
```



<!----------------------------slide boundary--------------------------------->


## References
